// Generated by github.com/steida/coffee2closure 0.0.14
"use strict";
var BROWSER_IS_IE7, BROWSER_SCROLLBAR_WIDTH, DOMSCROLL, DOWN, DRAG, ENTER, KEYDOWN, KEYUP, MOUSEDOWN, MOUSEENTER, MOUSEMOVE, MOUSEUP, MOUSEWHEEL, PANEDOWN, RESIZE, SCROLL, SCROLLBAR, TOUCHMOVE, UP, WHEEL, defaults, getBrowserScrollbarWidth, getHeight, getWindow, hackPercentMargin, hasTransform, isFFWithBuggyScrollbar, offset, scrollToInt, transform, trigger, wrap, _elementStyle, _prefixStyle, _vendor;
goog.provide('NanoScroll');
goog.require('goog.dom');
goog.require('goog.style');
goog.require('goog.events');
defaults = {
  'paneClass': 'nano-pane',
  'sliderClass': 'nano-slider',
  'contentClass': 'nano-content',
  'iOSNativeScrolling': false,
  'preventPageScrolling': false,
  'disableResize': false,
  'alwaysVisible': false,
  'flashDelay': 1500,
  'sliderMinHeight': 50,
  'sliderMaxHeight': null,
  'documentContext': null,
  'windowContext': null
};
SCROLLBAR = 'scrollbar';
SCROLL = 'scroll';
MOUSEDOWN = 'mousedown';
MOUSEENTER = 'mouseenter';
MOUSEMOVE = 'mousemove';
MOUSEWHEEL = 'mousewheel';
MOUSEUP = 'mouseup';
RESIZE = 'resize';
DRAG = 'drag';
ENTER = 'enter';
UP = 'up';
PANEDOWN = 'panedown';
DOMSCROLL = 'DOMMouseScroll';
DOWN = 'down';
WHEEL = 'wheel';
KEYDOWN = 'keydown';
KEYUP = 'keyup';
TOUCHMOVE = 'touchmove';
BROWSER_IS_IE7 = navigator.appName === 'Microsoft Internet Explorer' && /msie 7./i.test(navigator.appVersion) && window.ActiveXObject;
BROWSER_SCROLLBAR_WIDTH = null;
_elementStyle = (goog.dom.createElement('div')).style;
_vendor = (function() {
  var i, transform, vendor, vendors, _i, _len;
  vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'];
  for (i = _i = 0, _len = vendors.length; _i < _len; i = ++_i) {
    vendor = vendors[i];
    transform = vendors[i] + 'ransform';
    if (transform in _elementStyle) {
      return vendors[i].substr(0, vendors[i].length - 1);
    }
  }
  return false;
})();
_prefixStyle = function(style) {
  if (_vendor === false) {
    return false;
  }
  if (_vendor === '') {
    return style;
  }
  return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
};
transform = _prefixStyle('transform');
hasTransform = transform !== false;

/**
	Returns browser's native scrollbar width
*/
getBrowserScrollbarWidth = function() {
  var outer, scrollbarWidth;
  outer = goog.dom.createElement('div');
  goog.style.setStyle(outer, 'position', 'absolute');
  goog.style.setStyle(outer, 'width', '100px');
  goog.style.setStyle(outer, 'height', '100px');
  goog.style.setStyle(outer, 'overflow', SCROLL);
  goog.style.setStyle(outer, 'top', '-9999px');
  goog.dom.appendChild(document.body, outer);
  scrollbarWidth = outer.offsetWidth - outer.clientWidth;
  goog.dom.removeNode(outer);
  return scrollbarWidth;
};
isFFWithBuggyScrollbar = function() {
  var isOSXFF, ua, version;
  ua = window.navigator.userAgent;
  isOSXFF = /(?=.+Mac OS X)(?=.+Firefox)/.test(ua);
  if (!isOSXFF) {
    return false;
  }
  version = /Firefox\/\d{2}\./.exec(ua);
  if (version) {
    version = version[0].replace(/\D+/g, '');
  }
  return isOSXFF && +version > 23;
};

/**
*/
hackPercentMargin = function(elem, marginValue) {
  var originalWidth, ret;
  if (marginValue.indexOf("%") === -1) {
    return marginValue;
  }
  originalWidth = elem.style.width;
  elem.style.width = marginValue;
  ret = goog.style.getStyle(elem, 'width');
  elem.style.width = originalWidth;
  return ret;
};

/**
*/
getHeight = function(elem, isOuter) {
  var borderA, borderB, computedMarginA, computedMarginB, marginA, marginB, paddingA, paddingB, val;
  val = elem.offsetHeight;
  paddingA = parseFloat(goog.style.getStyle(elem, "padding-top")) || 0;
  paddingB = parseFloat(goog.style.getStyle(elem, "padding-bottom")) || 0;
  borderA = parseFloat(goog.style.getStyle(elem, "border-top-width")) || 0;
  borderB = parseFloat(goog.style.getStyle(elem, "border-bottom-width")) || 0;
  computedMarginA = goog.style.getStyle(elem, "margin-top");
  computedMarginB = goog.style.getStyle(elem, "margin-bottom");
  if (computedMarginA === '1%') {
    computedMarginA = hackPercentMargin(elem, computedMarginA);
    computedMarginB = hackPercentMargin(elem, computedMarginB);
  }
  marginA = parseFloat(computedMarginA) || 0;
  marginB = parseFloat(computedMarginB) || 0;
  if (val > 0) {
    if (isOuter) {
      val += marginA + marginB;
    } else {
      val -= paddingA + paddingB + borderA + borderB;
    }
  } else {
    val = goog.style.getStyle(elem, 'height');
    if (val < 0 || val === null) {
      val = goog.style.getStyle(elem, 'height') || 0;
    }
    val = parseFloat(val) || 0;
    if (isOuter) {
      val += paddingA + paddingB + marginA + marginB + borderA + borderB;
    }
  }
  return val;
};
offset = function(elem) {
  var box, doc, docElem, win;
  box = {
    top: 0,
    left: 0
  };
  doc = elem && elem.ownerDocument;
  if (!doc) {
    return;
  }
  docElem = doc.documentElement;
  if (!goog.dom.contains(docElem, elem)) {
    return box;
  }
  if (typeof elem.getBoundingClientRect !== "undefined") {
    box = elem.getBoundingClientRect();
  }
  win = getWindow(doc);
  return {
    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
  };
};
getWindow = function(elem) {
  var ret, _ref;
  if (elem.nodeType === 9) {
    ret = elem.defaultView || elem.parentWindow;
  } else {
    ret = false;
  }
  return (_ref = elem !== null && elem === elem.window) != null ? _ref : {
    elem: ret
  };
};

/*
	@param element {Element}
	@param to {int}
*/
scrollToInt = function(element, to) {
  return element.scrollTop = to;
};

/**
	Wrap an HTMLElement around each element in an HTMLElement array.
*/
wrap = function(parent, elms) {
  var child, el, i, sibling;
  if (!elms.length) {
    elms = [elms];
  }
  i = elms.length - 1;
  while (i >= 0) {
    child = (i > 0 ? parent.cloneNode(true) : parent);
    el = elms[i];
    parent = el.parentNode;
    sibling = el.nextSibling;
    child.appendChild(el);
    if (sibling) {
      parent.insertBefore(child, sibling);
    } else {
      parent.appendChild(child);
    }
    i--;
  }
};

/**
	@class NanoScroll
	@param el {HTMLElement|Node} the main element
	@param options {Object} nanoScroller's options
	@constructor
*/
var NanoScroll = function(el, options) {
  this.el = el;
  this.options = options != null ? options : null;
  if (this.options === null) {
    this.options = defaults;
  }
  BROWSER_SCROLLBAR_WIDTH || (BROWSER_SCROLLBAR_WIDTH = getBrowserScrollbarWidth());
  this.doc = this.options['documentContext'] || document;
  this.win = this.options['windowContext'] || window;
  this.body = document.body;
  this.content = goog.dom.getElementByClass(this.options['contentClass'], this.el);
  if (this.content === null) {
    return;
  }
  this.content.setAttribute('tabindex', this.options['tabIndex'] || 0);
  this.previousPosition = 0;
  if (this.options['iOSNativeScrolling'] && ((goog.style.getStyle(this.el, '-webkit-overflow-scrolling')) != null)) {
    this.nativeScrolling();
  } else {
    this.generate();
  }
  this.createEvents();
  this.addEvents();
  this.reset();
}

/**
		Wraps element with nano div and execute script
		@param element {HTMLElement|Node} element to wrap
		@param options {Object} nanoScroller's options
*/
NanoScroll.wrap = function(element, options) {
  var wrapper;
  if (options == null) {
    options = null;
  }
  element.classList.add('nano-content');
  wrapper = goog.dom.createDom('div', {
    'class': 'nano'
  });
  wrap(wrapper, element);
  return new NanoScroll(wrapper, options);
};

/**
		Prevents the rest of the page being scrolled
		when user scrolls the `.nano-content` element.
		@param e {Event}
		@param direction {String} Scroll direction (up or down)
*/
NanoScroll.prototype.preventScrolling = function(e, direction) {
  if (!this.isActive) {
    return;
  }
  if (e.type === DOMSCROLL) {
    if (direction === DOWN && e.detail > 0 || direction === UP && e.detail < 0) {
      e.preventDefault();
    }
  } else if (e.type === MOUSEWHEEL) {
    if (!e.or(!e.wheelDelta)) {
      return;
    }
    if (direction === DOWN && e.wheelDelta < 0 || direction === UP && e.wheelDelta > 0) {
      e.preventDefault();
    }
  }
};

/**
		Enable iOS native scrolling
*/
NanoScroll.prototype.nativeScrolling = function() {
  goog.style.setStyle(this.content, '-webkit-overflow-scrolling', 'touch');
  this.iOSNativeScrolling = true;
  this.isActive = true;
};

/**
		Updates those nanoScroller properties that
		are related to current scrollbar position.
*/
NanoScroll.prototype.updateScrollValues = function() {
  var direction;
  this.maxScrollTop = this.content.scrollHeight - this.content.clientHeight;
  this.prevScrollTop = this.contentScrollTop || 0;
  this.contentScrollTop = this.content.scrollTop;
  direction = this.contentScrollTop > this.previousPosition ? "down" : this.contentScrollTop < this.previousPosition ? "up" : "same";
  this.previousPosition = this.contentScrollTop;
  if (direction !== 'same') {
    trigger(this.el, 'update', {
      'position': this.contentScrollTop,
      'maximum': this.maxScrollTop,
      'direction': direction
    });
  }
  if (!this.iOSNativeScrolling) {
    this.maxSliderTop = this.paneHeight - this.sliderHeight;
    this.sliderTop = this.maxScrollTop === 0 ? 0 : this.contentScrollTop * this.maxSliderTop / this.maxScrollTop;
  }
};

/**
		Updates CSS styles for current scroll position.
		Uses CSS 2d transfroms and `window.requestAnimationFrame` if available.
*/
NanoScroll.prototype.setOnScrollStyles = function() {
  var cssValue,
    _this = this;
  if (this.lastSliderTop && this.lastSliderTop.toFixed(2) === this.sliderTop.toFixed(2)) {
    return;
  }
  this.lastSliderTop = this.sliderTop;
  if (hasTransform) {
    cssValue = {
      transform: "translate(0, " + this.sliderTop + "px)"
    };
  } else {
    cssValue = {
      top: "" + this.sliderTop + "px"
    };
  }
  if (window.requestAnimationFrame) {
    if (window.cancelAnimationFrame && this.scrollRAF) {
      window.cancelAnimationFrame(this.scrollRAF);
    }
    this.scrollRAF = window.requestAnimationFrame(function() {
      _this.scrollRAF = null;
      return goog.style.setStyle(_this.slider, cssValue);
    });
  } else {
    goog.style.setStyle(this.slider, cssValue);
  }
};

/**
		Creates event related methods
*/
NanoScroll.prototype.createEvents = function() {
  var _this = this;
  this.events = {
    'domchanged': function() {
      return _this.reset();
    },
    
/**
    				@param e {Event}
    */
    'down': function(e) {
      _this.isBeingDragged = true;
      _this.offsetY = (Math.max(0, e.clientY)) - offset(_this.slider)['top'];
      if (e.target !== _this.slider) {
        _this.offsetY = 0;
      }
      _this.pane.classList.add('active');
      goog.dom.getElement('body').classList.add('non-selectable');
      goog.events.listen(_this.doc, MOUSEMOVE, _this.events[DRAG]);
      goog.events.listen(_this.doc, MOUSEUP, _this.events[UP]);
      return false;
    },
    
/**
    				@param e {Event}
    */
    'drag': function(e) {
      _this.sliderY = (Math.max(0, e.clientY)) - offset(_this.content)['top'] - _this.paneTop - (_this.offsetY || _this.sliderHeight * 0.5);
      _this.scroll();
      if (_this.contentScrollTop >= _this.maxScrollTop && _this.prevScrollTop !== _this.maxScrollTop) {
        trigger(_this.el, 'scrollend', null);
      } else if (_this.contentScrollTop === 0 && _this.prevScrollTop !== 0) {
        trigger(_this.el, 'scrolltop', null);
      }
      return false;
    },
    'up': function() {
      _this.isBeingDragged = false;
      _this.pane.classList.remove('active');
      goog.dom.getElement('body').classList.remove('non-selectable');
      goog.events.unlisten(_this.doc, MOUSEMOVE, _this.events[DRAG]);
      goog.events.unlisten(_this.doc, MOUSEUP, _this.events[UP]);
      return false;
    },
    'resize': function() {
      return _this.reset();
    },
    
/**
    				@param e {Event}
    */
    'panedown': function(e) {
      if (e.target === _this.slider) {
        return;
      }
      _this.sliderY = (e.offsetY || e.layerY) - (_this.sliderHeight * 0.5);
      _this.scroll();
      _this.events[DOWN](e);
      return false;
    },
    
/**
    				@param e {Event}
    */
    'scroll': function(e) {
      _this.updateScrollValues();
      if (_this.isBeingDragged) {
        return;
      }
      if (!_this.iOSNativeScrolling) {
        _this.sliderY = _this.sliderTop;
        _this.setOnScrollStyles();
      }
      if (e == null) {
        return;
      }
      if (_this.contentScrollTop >= _this.maxScrollTop) {
        if (_this.options['preventPageScrolling']) {
          _this.preventScrolling(e, DOWN);
        }
        if (_this.prevScrollTop !== _this.maxScrollTop) {
          trigger(_this.el, 'scrollend', null);
        }
      } else if (_this.contentScrollTop === 0) {
        if (_this.options['preventPageScrolling']) {
          _this.preventScrolling(e, UP);
        }
        if (_this.prevScrollTop !== 0) {
          trigger(_this.el, 'scrolltop', null);
        }
      }
    },
    
/**
    				@param e {Event}
    */
    'enter': function(e) {
      var _ref;
      if (!_this.isBeingDragged) {
        return;
      }
      if ((e.buttons || e.which) !== 1) {
        return (_ref = _this.events)[UP].apply(_ref, arguments);
      }
    }
  };
};

/**
		Adds event listeners
*/
NanoScroll.prototype.addEvents = function() {
  this.removeEvents();
  if (!this.options['disableResize']) {
    goog.events.listen(this.win, RESIZE, this.events[RESIZE]);
  }
  if (!this.iOSNativeScrolling) {
    goog.events.listen(this.slider, MOUSEDOWN, this.events[DOWN]);
    goog.events.listen(this.pane, MOUSEDOWN, this.events[PANEDOWN]);
  }
  goog.events.listen(this.content, [SCROLL, MOUSEWHEEL, DOMSCROLL, TOUCHMOVE], this.events[SCROLL]);
  goog.events.listen(this.content, ['DOMNodeInserted', 'DOMNodeRemoved'], this.events['domchanged']);
};

/**
		Removes event listeners
*/
NanoScroll.prototype.removeEvents = function() {
  var events;
  events = this.events;
  goog.events.unlisten(this.win, RESIZE, events[RESIZE]);
  if (!this.iOSNativeScrolling) {
    goog.events.removeAll(this.slider);
    goog.events.removeAll(this.pane);
  }
  goog.events.unlisten(this.content, [SCROLL, MOUSEWHEEL, DOMSCROLL, TOUCHMOVE], events[SCROLL]);
};

/**
		Generates nanoScroller's scrollbar and elements for it
*/
NanoScroll.prototype.generate = function() {
  var contentClass, cssRule, currentPadding, div, pane, paneClass, sliderClass;
  paneClass = this.options['paneClass'];
  sliderClass = this.options['sliderClass'];
  contentClass = this.options['contentClass'];
  if (!(pane = this.el.getElementsByClassName(paneClass)).length && !pane.namedItem(sliderClass)) {
    div = goog.dom.createDom('div', {
      'class': paneClass
    });
    goog.dom.appendChild(div, goog.dom.createDom('div', {
      'class': sliderClass
    }));
    goog.dom.appendChild(this.el, div);
  }
  this.pane = goog.dom.getElementByClass(paneClass, this.el);
  this.slider = goog.dom.getElementByClass(sliderClass, this.pane);
  if (BROWSER_SCROLLBAR_WIDTH === 0 && isFFWithBuggyScrollbar()) {
    currentPadding = window.getComputedStyle(this.content, null).getPropertyValue('padding-right').replace(/\D+/g, '');
    cssRule = {
      'right': '-14px',
      'padding-right': "" + (+currentPadding + 14) + "px"
    };
  } else if (BROWSER_SCROLLBAR_WIDTH) {
    cssRule = {
      'right': "" + (-BROWSER_SCROLLBAR_WIDTH) + "px",
      'padding-right': '10px'
    };
    this.el.classList.add('has-scrollbar');
  }
  if (cssRule != null) {
    goog.style.setStyle(this.content, cssRule);
  }
  return this;
};
NanoScroll.prototype.restore = function() {
  this.stopped = false;
  if (!this.iOSNativeScrolling) {
    goog.style.setElementShown(this.pane, true);
  }
  this.addEvents();
};

/**
		Resets nanoScroller's scrollbar.
*/
NanoScroll.prototype.reset = function() {
  var contentHeight, contentPosition, contentStyleOverflowY, paneBottom, paneHeight, paneOuterHeight, paneTop, parentMaxHeight, right, sliderHeight;
  if (this.iOSNativeScrolling) {
    this.contentHeight = this.content.scrollHeight;
    return;
  }
  if (!goog.dom.getElementsByClass(this.options['paneClass'], this.el).length) {
    this.generate().stop();
  }
  if (this.stopped) {
    this.restore();
  }
  contentStyleOverflowY = goog.style.getStyle(this.content, 'overflow-y');
  if (BROWSER_IS_IE7) {
    goog.style.setStyle(this.content, 'height', this.content.clientHeight);
  }
  contentHeight = this.content.scrollHeight + BROWSER_SCROLLBAR_WIDTH;
  parentMaxHeight = parseInt(goog.style.getStyle(this.content, 'max-height'), 10);
  if (parentMaxHeight > 0) {
    goog.style.setStyle(this.content, 'height', '');
    goog.style.setStyle(this.content, 'height', "" + (this.content.scrollHeight > parentMaxHeight ? parentMaxHeight : this.content.scrollHeight) + "px");
  }
  paneHeight = getHeight(this.pane, true);
  paneTop = parseInt(goog.style.getStyle(this.pane, 'top'), 10) || 0;
  paneBottom = parseInt(goog.style.getStyle(this.pane, 'bottom'), 10) || 0;
  paneOuterHeight = paneHeight + paneTop + paneBottom;
  sliderHeight = Math.round(paneOuterHeight / contentHeight * paneOuterHeight);
  if (sliderHeight < this.options['sliderMinHeight']) {
    sliderHeight = this.options['sliderMinHeight'];
  } else if ((this.options['sliderMaxHeight'] != null) && sliderHeight > this.options['sliderMaxHeight']) {
    sliderHeight = this.options['sliderMaxHeight'];
  }
  if (contentStyleOverflowY === SCROLL && goog.style.getStyle(this.content, 'overflow-x') !== SCROLL) {
    sliderHeight += BROWSER_SCROLLBAR_WIDTH;
  }
  this.maxSliderTop = paneOuterHeight - sliderHeight;
  this.contentHeight = contentHeight;
  this.paneHeight = paneHeight;
  this.paneOuterHeight = paneOuterHeight;
  this.sliderHeight = sliderHeight;
  this.paneTop = paneTop;
  goog.style.setStyle(this.slider, 'height', "" + sliderHeight + "px");
  this.events.scroll();
  goog.style.setElementShown(this.pane, true);
  this.isActive = true;
  if ((this.content.scrollHeight === this.content.clientHeight) || (getHeight(this.pane, true) >= this.content.scrollHeight && contentStyleOverflowY !== SCROLL)) {
    goog.style.setElementShown(this.slider, false);
    this.isActive = false;
  } else if (this.content.clientHeight === this.content.scrollHeight && contentStyleOverflowY === SCROLL) {
    goog.style.setElementShown(this.slider, false);
  } else {
    goog.style.setElementShown(this.slider, true);
  }
  goog.style.setStyle(this.pane, {
    opacity: (this.options['alwaysVisible'] ? 1 : ''),
    visibility: (this.options['alwaysVisible'] ? 'visible' : '')
  });
  contentPosition = goog.style.getStyle(this.content, 'position');
  if (contentPosition === 'static' || contentPosition === 'relative') {
    right = parseInt(goog.style.getStyle(this.content, 'right'), 10);
    if (right) {
      goog.style.setStyle(this.content, 'right', '');
      goog.style.setStyle(this.content, 'margin-right', "" + right + "px");
    }
  }
  return this;
};
NanoScroll.prototype.scroll = function() {
  var val;
  if (!this.isActive) {
    return;
  }
  this.sliderY = Math.max(0, this.sliderY);
  this.sliderY = Math.min(this.maxSliderTop, this.sliderY);
  val = this.maxScrollTop * this.sliderY / this.maxSliderTop;
  scrollToInt(this.content, val);
  if (!this.iOSNativeScrolling) {
    this.updateScrollValues();
    this.setOnScrollStyles();
  }
  return this;
};

/**
		Scroll at the bottom with an offset value
		@param offsetY {Number}
*/
NanoScroll.prototype.scrollBottom = function(offsetY) {
  if (!this.isActive) {
    return;
  }
  scrollToInt(this.content, this.contentHeight - this.content.clientHeight - offsetY);
  trigger(this.content, MOUSEWHEEL, null);
  this.stop().restore();
  return this;
};

/**
		Scroll at the top with an offset value
		@param offsetY {Number}
*/
NanoScroll.prototype.scrollTop = function(offsetY) {
  if (!this.isActive) {
    return;
  }
  scrollToInt(this.content, offsetY);
  trigger(this.content, MOUSEWHEEL, null);
  this.stop().restore();
  return this;
};

/**
		Scroll to an element
		@param node {Node} A node to scroll to.
*/
NanoScroll.prototype.scrollTo = function(node) {
  var el;
  if (!this.isActive) {
    el = goog.dom.getElement(node);
    return this.scrollTop(el.offsetTop);
  }
  return this;
};

/**
		To stop the operation.
		This option will tell the plugin to disable all event bindings and hide the gadget scrollbar from the UI.
*/
NanoScroll.prototype.stop = function() {
  if (window.cancelAnimationFrame && this.scrollRAF) {
    window.cancelAnimationFrame(this.scrollRAF);
    this.scrollRAF = null;
  }
  this.stopped = true;
  this.removeEvents();
  if (!this.iOSNativeScrolling) {
    goog.style.setElementShown(this.pane, false)();
  }
  return this;
};

/**
		Destroys nanoScroller and restores browser's native scrollbar.
*/
NanoScroll.prototype.destroy = function() {
  if (!this.stopped) {
    this.stop();
  }
  if (!this.iOSNativeScrolling && this.pane.length) {
    goog.dom.removeNode(this.pane);
  }
  if (BROWSER_IS_IE7) {
    goog.style.setStyle(this.content, 'height', '');
  }
  this.content.removeAttribute('tabindex');
  if (this.content.classList.contains('has-scrollbar')) {
    this.content.classList.remove('has-scrollbar');
    goog.style.setStyle(this.content, 'right', '');
  }
  return this;
};

/**
		To flash the scrollbar gadget for an amount of time defined in plugin settings (defaults to 1,5s).
		Useful if you want to show the user (e.g. on pageload) that there is more content waiting for him.
*/
NanoScroll.prototype.flash = function() {
  var _this = this;
  if (this.iOSNativeScrolling) {
    return;
  }
  if (!this.isActive) {
    return;
  }
  this.reset();
  this.pane.classList.add('flashed');
  setTimeout(function() {
    _this.pane.classList.remove('flashed');
  }, this.options['flashDelay']);
  return this;
};

/*
	Triggers event
	@param el {Element}
	@param type {String}
	@param data {mixed}
*/
trigger = function(el, type, data) {
  var event;
  event = document.createEvent("HTMLEvents");
  event.initEvent(type, true, true);
  event.data = data || {};
  event.eventName = type;
  el.dispatchEvent(event);
  return true;
};